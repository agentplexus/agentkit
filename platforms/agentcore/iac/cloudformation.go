// Package iac provides shared infrastructure-as-code configuration for AgentCore deployments.
package iac

import (
	"fmt"
	"os"
	"strings"

	"gopkg.in/yaml.v3"
)

// CloudFormationTemplate represents a CloudFormation template structure.
type CloudFormationTemplate struct {
	AWSTemplateFormatVersion string                 `yaml:"AWSTemplateFormatVersion"`
	Description              string                 `yaml:"Description,omitempty"`
	Parameters               map[string]CFParameter `yaml:"Parameters,omitempty"`
	Resources                map[string]CFResource  `yaml:"Resources"`
	Outputs                  map[string]CFOutput    `yaml:"Outputs,omitempty"`
	Metadata                 map[string]interface{} `yaml:"Metadata,omitempty"`
}

// CFParameter represents a CloudFormation parameter.
type CFParameter struct {
	Type          string   `yaml:"Type"`
	Description   string   `yaml:"Description,omitempty"`
	Default       string   `yaml:"Default,omitempty"`
	AllowedValues []string `yaml:"AllowedValues,omitempty"`
	NoEcho        bool     `yaml:"NoEcho,omitempty"`
}

// CFResource represents a CloudFormation resource.
type CFResource struct {
	Type           string                 `yaml:"Type"`
	Properties     map[string]interface{} `yaml:"Properties,omitempty"`
	DependsOn      []string               `yaml:"DependsOn,omitempty"`
	DeletionPolicy string                 `yaml:"DeletionPolicy,omitempty"`
	Metadata       map[string]interface{} `yaml:"Metadata,omitempty"`
}

// CFOutput represents a CloudFormation output.
type CFOutput struct {
	Description string      `yaml:"Description,omitempty"`
	Value       interface{} `yaml:"Value"`
	Export      *CFExport   `yaml:"Export,omitempty"`
}

// CFExport represents a CloudFormation export.
type CFExport struct {
	Name interface{} `yaml:"Name"`
}

// GenerateCloudFormation generates a CloudFormation template from StackConfig.
// This allows deploying without CDK - just use `aws cloudformation deploy`.
//
// Example:
//
//	config, _ := iac.LoadStackConfigFromFile("config.yaml")
//	template, _ := iac.GenerateCloudFormation(config)
//	os.WriteFile("template.yaml", template, 0644)
//	// Then: aws cloudformation deploy --template-file template.yaml --stack-name my-stack
func GenerateCloudFormation(config *StackConfig) ([]byte, error) {
	config.ApplyDefaults()
	if err := config.Validate(); err != nil {
		return nil, fmt.Errorf("invalid configuration: %w", err)
	}

	template := &CloudFormationTemplate{
		AWSTemplateFormatVersion: "2010-09-09",
		Description:              config.Description,
		Parameters:               make(map[string]CFParameter),
		Resources:                make(map[string]CFResource),
		Outputs:                  make(map[string]CFOutput),
		Metadata: map[string]interface{}{
			"Generator": "agentkit",
			"Version":   "1.0.0",
		},
	}

	// Add parameters
	addParameters(template, config)

	// Add VPC resources
	if config.VPC.CreateVPC {
		addVPCResources(template, config)
	}

	// Add IAM resources
	addIAMResources(template, config)

	// Add CloudWatch Log Group
	if config.Observability.EnableCloudWatchLogs {
		addLogGroupResource(template, config)
	}

	// Add agent-related outputs and comments
	addAgentOutputs(template, config)

	// Add outputs
	addOutputs(template, config)

	// Marshal to YAML
	data, err := yaml.Marshal(template)
	if err != nil {
		return nil, fmt.Errorf("failed to generate YAML: %w", err)
	}

	// Add header comment
	header := fmt.Sprintf(`# CloudFormation template generated by agentkit
# Stack: %s
#
# Deploy with:
#   aws cloudformation deploy \
#     --template-file template.yaml \
#     --stack-name %s \
#     --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM
#
# Note: This template creates foundational resources (VPC, IAM, Logs).
# AgentCore agent resources should be created via AWS Console or CLI
# once AgentCore GA APIs are available.

`, config.StackName, config.StackName)

	return []byte(header + string(data)), nil
}

// addParameters adds CloudFormation parameters.
func addParameters(template *CloudFormationTemplate, config *StackConfig) {
	template.Parameters["Environment"] = CFParameter{
		Type:          "String",
		Description:   "Deployment environment",
		Default:       "production",
		AllowedValues: []string{"development", "staging", "production"},
	}

	// Add parameters for each agent's container image
	for _, agent := range config.Agents {
		paramName := fmt.Sprintf("%sContainerImage", toPascalCase(agent.Name))
		template.Parameters[paramName] = CFParameter{
			Type:        "String",
			Description: fmt.Sprintf("Container image for %s agent", agent.Name),
			Default:     agent.ContainerImage,
		}
	}

	// Add observability API key parameter if needed
	if config.Observability.Provider != "cloudwatch" && config.Observability.Provider != "" {
		template.Parameters["ObservabilityAPIKey"] = CFParameter{
			Type:        "String",
			Description: fmt.Sprintf("API key for %s observability", config.Observability.Provider),
			NoEcho:      true,
			Default:     "",
		}
	}
}

// addVPCResources adds VPC-related CloudFormation resources.
func addVPCResources(template *CloudFormationTemplate, config *StackConfig) {
	stackName := config.StackName

	// VPC
	template.Resources["VPC"] = CFResource{
		Type: "AWS::EC2::VPC",
		Properties: map[string]interface{}{
			"CidrBlock":          config.VPC.VPCCidr,
			"EnableDnsHostnames": true,
			"EnableDnsSupport":   true,
			"Tags": []map[string]interface{}{
				{"Key": "Name", "Value": fmt.Sprintf("%s-vpc", stackName)},
				{"Key": "ManagedBy", "Value": "agentkit"},
			},
		},
	}

	// Internet Gateway
	template.Resources["InternetGateway"] = CFResource{
		Type: "AWS::EC2::InternetGateway",
		Properties: map[string]interface{}{
			"Tags": []map[string]interface{}{
				{"Key": "Name", "Value": fmt.Sprintf("%s-igw", stackName)},
			},
		},
	}

	// VPC Gateway Attachment
	template.Resources["VPCGatewayAttachment"] = CFResource{
		Type: "AWS::EC2::VPCGatewayAttachment",
		Properties: map[string]interface{}{
			"VpcId":             map[string]string{"Ref": "VPC"},
			"InternetGatewayId": map[string]string{"Ref": "InternetGateway"},
		},
	}

	// Public Subnet
	template.Resources["PublicSubnet1"] = CFResource{
		Type: "AWS::EC2::Subnet",
		Properties: map[string]interface{}{
			"VpcId":               map[string]string{"Ref": "VPC"},
			"CidrBlock":           "10.0.1.0/24",
			"AvailabilityZone":    map[string]interface{}{"Fn::Select": []interface{}{0, map[string]string{"Fn::GetAZs": ""}}},
			"MapPublicIpOnLaunch": true,
			"Tags": []map[string]interface{}{
				{"Key": "Name", "Value": fmt.Sprintf("%s-public-1", stackName)},
			},
		},
	}

	// Private Subnet
	template.Resources["PrivateSubnet1"] = CFResource{
		Type: "AWS::EC2::Subnet",
		Properties: map[string]interface{}{
			"VpcId":            map[string]string{"Ref": "VPC"},
			"CidrBlock":        "10.0.10.0/24",
			"AvailabilityZone": map[string]interface{}{"Fn::Select": []interface{}{0, map[string]string{"Fn::GetAZs": ""}}},
			"Tags": []map[string]interface{}{
				{"Key": "Name", "Value": fmt.Sprintf("%s-private-1", stackName)},
			},
		},
	}

	// NAT Gateway EIP
	template.Resources["NATGatewayEIP"] = CFResource{
		Type:      "AWS::EC2::EIP",
		DependsOn: []string{"VPCGatewayAttachment"},
		Properties: map[string]interface{}{
			"Domain": "vpc",
		},
	}

	// NAT Gateway
	template.Resources["NATGateway"] = CFResource{
		Type: "AWS::EC2::NatGateway",
		Properties: map[string]interface{}{
			"AllocationId": map[string]interface{}{"Fn::GetAtt": []string{"NATGatewayEIP", "AllocationId"}},
			"SubnetId":     map[string]string{"Ref": "PublicSubnet1"},
			"Tags": []map[string]interface{}{
				{"Key": "Name", "Value": fmt.Sprintf("%s-nat", stackName)},
			},
		},
	}

	// Security Group
	template.Resources["SecurityGroup"] = CFResource{
		Type: "AWS::EC2::SecurityGroup",
		Properties: map[string]interface{}{
			"GroupDescription": fmt.Sprintf("Security group for %s AgentCore agents", stackName),
			"VpcId":            map[string]string{"Ref": "VPC"},
			"SecurityGroupIngress": []map[string]interface{}{
				{
					"IpProtocol":            "-1",
					"SourceSecurityGroupId": map[string]string{"Ref": "SecurityGroup"},
					"Description":           "Allow communication between agents",
				},
			},
			"SecurityGroupEgress": []map[string]interface{}{
				{
					"IpProtocol":  "-1",
					"CidrIp":      "0.0.0.0/0",
					"Description": "Allow all outbound traffic",
				},
			},
			"Tags": []map[string]interface{}{
				{"Key": "Name", "Value": fmt.Sprintf("%s-sg", stackName)},
			},
		},
	}
}

// addIAMResources adds IAM-related CloudFormation resources.
func addIAMResources(template *CloudFormationTemplate, config *StackConfig) {
	stackName := config.StackName

	// Execution Role
	template.Resources["ExecutionRole"] = CFResource{
		Type: "AWS::IAM::Role",
		Properties: map[string]interface{}{
			"RoleName": fmt.Sprintf("%s-execution-role", stackName),
			"AssumeRolePolicyDocument": map[string]interface{}{
				"Version": "2012-10-17",
				"Statement": []map[string]interface{}{
					{
						"Effect": "Allow",
						"Principal": map[string]interface{}{
							"Service": []string{
								"bedrock.amazonaws.com",
								"lambda.amazonaws.com",
							},
						},
						"Action": "sts:AssumeRole",
					},
				},
			},
			"Policies": []map[string]interface{}{
				{
					"PolicyName": "AgentCorePolicy",
					"PolicyDocument": map[string]interface{}{
						"Version":   "2012-10-17",
						"Statement": buildIAMStatements(config),
					},
				},
			},
			"Tags": []map[string]interface{}{
				{"Key": "Name", "Value": fmt.Sprintf("%s-execution-role", stackName)},
				{"Key": "ManagedBy", "Value": "agentkit"},
			},
		},
	}
}

// buildIAMStatements builds IAM policy statements based on config.
func buildIAMStatements(config *StackConfig) []map[string]interface{} {
	statements := []map[string]interface{}{
		// CloudWatch Logs
		{
			"Effect": "Allow",
			"Action": []string{
				"logs:CreateLogGroup",
				"logs:CreateLogStream",
				"logs:PutLogEvents",
			},
			"Resource": "arn:aws:logs:*:*:*",
		},
		// ECR
		{
			"Effect": "Allow",
			"Action": []string{
				"ecr:GetAuthorizationToken",
				"ecr:BatchCheckLayerAvailability",
				"ecr:GetDownloadUrlForLayer",
				"ecr:BatchGetImage",
			},
			"Resource": "*",
		},
	}

	// Bedrock access
	if config.IAM.EnableBedrockAccess {
		bedrockStatement := map[string]interface{}{
			"Effect": "Allow",
			"Action": []string{
				"bedrock:InvokeModel",
				"bedrock:InvokeModelWithResponseStream",
			},
		}
		if len(config.IAM.BedrockModelIDs) > 0 {
			resources := make([]string, len(config.IAM.BedrockModelIDs))
			for i, modelID := range config.IAM.BedrockModelIDs {
				resources[i] = fmt.Sprintf("arn:aws:bedrock:*:*:foundation-model/%s", modelID)
			}
			bedrockStatement["Resource"] = resources
		} else {
			bedrockStatement["Resource"] = "arn:aws:bedrock:*:*:foundation-model/*"
		}
		statements = append(statements, bedrockStatement)
	}

	// Secrets Manager access
	hasSecrets := false
	for _, agent := range config.Agents {
		if len(agent.SecretsARNs) > 0 {
			hasSecrets = true
			break
		}
	}
	if hasSecrets {
		statements = append(statements, map[string]interface{}{
			"Effect": "Allow",
			"Action": []string{
				"secretsmanager:GetSecretValue",
			},
			"Resource": "*", // Should be scoped to specific secrets in production
		})
	}

	return statements
}

// addLogGroupResource adds CloudWatch Log Group resource.
func addLogGroupResource(template *CloudFormationTemplate, config *StackConfig) {
	deletionPolicy := "Delete"
	if config.RemovalPolicy == "retain" {
		deletionPolicy = "Retain"
	}

	template.Resources["LogGroup"] = CFResource{
		Type:           "AWS::Logs::LogGroup",
		DeletionPolicy: deletionPolicy,
		Properties: map[string]interface{}{
			"LogGroupName":    fmt.Sprintf("/aws/agentcore/%s", config.StackName),
			"RetentionInDays": config.Observability.LogRetentionDays,
			"Tags": []map[string]interface{}{
				{"Key": "Name", "Value": fmt.Sprintf("%s-logs", config.StackName)},
				{"Key": "ManagedBy", "Value": "agentkit"},
			},
		},
	}
}

// addAgentOutputs adds outputs documenting agent configuration.
func addAgentOutputs(template *CloudFormationTemplate, config *StackConfig) {
	for i, agent := range config.Agents {
		template.Outputs[fmt.Sprintf("Agent%dName", i+1)] = CFOutput{
			Description: fmt.Sprintf("Agent %d name", i+1),
			Value:       agent.Name,
		}
		template.Outputs[fmt.Sprintf("Agent%dImage", i+1)] = CFOutput{
			Description: fmt.Sprintf("Agent %d container image", i+1),
			Value:       map[string]string{"Ref": fmt.Sprintf("%sContainerImage", toPascalCase(agent.Name))},
		}
		template.Outputs[fmt.Sprintf("Agent%dMemory", i+1)] = CFOutput{
			Description: fmt.Sprintf("Agent %d memory (MB)", i+1),
			Value:       fmt.Sprintf("%d", agent.MemoryMB),
		}
	}
}

// addOutputs adds CloudFormation outputs.
func addOutputs(template *CloudFormationTemplate, config *StackConfig) {
	if config.VPC.CreateVPC {
		template.Outputs["VPCID"] = CFOutput{
			Description: "VPC ID",
			Value:       map[string]string{"Ref": "VPC"},
			Export: &CFExport{
				Name: map[string]interface{}{"Fn::Sub": "${AWS::StackName}-VPCID"},
			},
		}

		template.Outputs["SecurityGroupID"] = CFOutput{
			Description: "Security Group ID",
			Value:       map[string]string{"Ref": "SecurityGroup"},
			Export: &CFExport{
				Name: map[string]interface{}{"Fn::Sub": "${AWS::StackName}-SecurityGroupID"},
			},
		}

		template.Outputs["PrivateSubnetID"] = CFOutput{
			Description: "Private Subnet ID",
			Value:       map[string]string{"Ref": "PrivateSubnet1"},
		}
	}

	template.Outputs["ExecutionRoleARN"] = CFOutput{
		Description: "IAM Execution Role ARN",
		Value:       map[string]interface{}{"Fn::GetAtt": []string{"ExecutionRole", "Arn"}},
		Export: &CFExport{
			Name: map[string]interface{}{"Fn::Sub": "${AWS::StackName}-ExecutionRoleARN"},
		},
	}

	if config.Observability.EnableCloudWatchLogs {
		template.Outputs["LogGroupName"] = CFOutput{
			Description: "CloudWatch Log Group Name",
			Value:       map[string]string{"Ref": "LogGroup"},
		}
	}

	template.Outputs["AgentCount"] = CFOutput{
		Description: "Number of agents configured",
		Value:       fmt.Sprintf("%d", len(config.Agents)),
	}
}

// GenerateCloudFormationFile generates a CloudFormation template and writes it to a file.
func GenerateCloudFormationFile(config *StackConfig, outputPath string) error {
	template, err := GenerateCloudFormation(config)
	if err != nil {
		return err
	}

	return os.WriteFile(outputPath, template, 0600)
}

// GenerateCloudFormationFromFile loads a config file and generates CloudFormation.
func GenerateCloudFormationFromFile(configPath, outputPath string) error {
	config, err := LoadStackConfigFromFile(configPath)
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	return GenerateCloudFormationFile(config, outputPath)
}

// toPascalCase converts a string to PascalCase.
func toPascalCase(s string) string {
	words := strings.FieldsFunc(s, func(r rune) bool {
		return r == '-' || r == '_' || r == ' '
	})

	for i, word := range words {
		if len(word) > 0 {
			words[i] = strings.ToUpper(word[:1]) + strings.ToLower(word[1:])
		}
	}

	return strings.Join(words, "")
}
