{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AgentKit","text":"<p>A Go library for building AI agent applications. Provides server factories, LLM abstractions, workflow orchestration, and multi-runtime deployment support.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Server Factories - A2A and HTTP servers in 5 lines (saves ~475 lines per project)</li> <li>Multi-Provider LLM - Gemini, Claude, OpenAI, xAI, Ollama via OmniLLM</li> <li>Workflow Orchestration - Type-safe graph-based execution with Eino</li> <li>Multi-Runtime Deployment - Kubernetes (Helm) or AWS AgentCore</li> <li>VaultGuard Integration - Security-gated credential access</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<pre><code>agentkit/\n\u251c\u2500\u2500 # Core (platform-agnostic)\n\u251c\u2500\u2500 a2a/             # A2A protocol server factory\n\u251c\u2500\u2500 agent/           # Base agent framework\n\u251c\u2500\u2500 config/          # Configuration management\n\u251c\u2500\u2500 http/            # HTTP client utilities\n\u251c\u2500\u2500 httpserver/      # HTTP server factory\n\u251c\u2500\u2500 llm/             # Multi-provider LLM abstraction\n\u251c\u2500\u2500 orchestration/   # Eino workflow orchestration\n\u2502\n\u251c\u2500\u2500 # Platform-specific\n\u2514\u2500\u2500 platforms/\n    \u251c\u2500\u2500 agentcore/   # AWS Bedrock AgentCore runtime\n    \u2514\u2500\u2500 kubernetes/  # Kubernetes + Helm deployment\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>package main\n\nimport (\n    \"context\"\n\n    \"github.com/agentplexus/agentkit/a2a\"\n    \"github.com/agentplexus/agentkit/agent\"\n    \"github.com/agentplexus/agentkit/config\"\n    \"github.com/agentplexus/agentkit/httpserver\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    cfg := config.LoadConfig()\n\n    // Create agent\n    ba, _ := agent.NewBaseAgent(cfg, \"research-agent\", 30)\n    researchAgent := NewResearchAgent(ba, cfg)\n\n    // HTTP server - 5 lines\n    httpServer, _ := httpserver.NewBuilder(\"research-agent\", 8001).\n        WithHandlerFunc(\"/research\", researchAgent.HandleResearch).\n        Build()\n\n    // A2A server - 5 lines\n    a2aServer, _ := a2a.NewServer(a2a.Config{\n        Agent:       researchAgent.ADKAgent(),\n        Port:        \"9001\",\n        Description: \"Research agent for web search\",\n    })\n\n    // Start servers\n    a2aServer.StartAsync(ctx)\n    httpServer.Start()\n}\n</code></pre>"},{"location":"#benefits","title":"Benefits","text":"<p>AgentKit eliminates ~1,500 lines of boilerplate per project:</p> Component Lines Saved A2A server factory ~350 lines HTTP server factory ~125 lines Shared pkg/ code ~930 lines <p>See the Benefits page for detailed analysis.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Installation - Add AgentKit to your project</li> <li>Quick Start - Build your first agent</li> <li>Local Development - Test locally before deploying</li> </ol>"},{"location":"benefits/","title":"Benefits","text":"<p>Quantified analysis of AgentKit's value proposition.</p>"},{"location":"benefits/#executive-summary","title":"Executive Summary","text":"<p>AgentKit saves ~1,500 lines (29%) per project and provides significant value when building multiple agent systems.</p>"},{"location":"benefits/#the-problem-boilerplate","title":"The Problem: Boilerplate","text":"<p>Every agent project repeats the same patterns:</p> Pattern Lines Duplicated A2A server setup ~350 lines HTTP server setup ~125 lines HTTP handler setup ~100 lines LLM factory ~200 lines Config management ~140 lines Total ~915 lines"},{"location":"benefits/#reference-stats-agent-team","title":"Reference: stats-agent-team","text":"<p>A multi-agent system for finding and verifying statistics:</p> <pre><code>stats-agent-team: 5,226 lines\n\u251c\u2500\u2500 Domain Logic:     ~3,500 lines (67%)\n\u2502   \u251c\u2500\u2500 Research agent logic\n\u2502   \u251c\u2500\u2500 Synthesis agent logic\n\u2502   \u251c\u2500\u2500 Verification agent logic\n\u2502   \u2514\u2500\u2500 Data models\n\u2502\n\u251c\u2500\u2500 Shared pkg/:      ~930 lines (18%)\n\u2502   \u251c\u2500\u2500 config/       137 lines\n\u2502   \u251c\u2500\u2500 llm/          308 lines\n\u2502   \u251c\u2500\u2500 agent/        143 lines\n\u2502   \u2514\u2500\u2500 httpclient/   89 lines\n\u2502\n\u2514\u2500\u2500 Boilerplate:      ~790 lines (15%)\n    \u251c\u2500\u2500 A2A server     350 lines\n    \u251c\u2500\u2500 HTTP server    125 lines\n    \u2514\u2500\u2500 HTTP handlers  100 lines\n</code></pre> <p>15% of the code is pure boilerplate.</p>"},{"location":"benefits/#quantified-savings","title":"Quantified Savings","text":""},{"location":"benefits/#per-project","title":"Per Project","text":"Component Lines Saved Replace <code>pkg/</code> with imports ~930 lines A2A server factory ~350 lines HTTP server factory ~125 lines HTTPHandler generic ~100 lines Total ~1,505 lines (29%)"},{"location":"benefits/#multiple-projects","title":"Multiple Projects","text":"Projects Lines Saved Benefit 1 1,500 Single codebase cleanup 2 3,000 Shared maintenance 5 7,500 Consistent patterns 10 15,000 Platform-level reuse <p>Each new project starts with 1,500 fewer lines to write.</p>"},{"location":"benefits/#server-factory-impact","title":"Server Factory Impact","text":""},{"location":"benefits/#a2a-server","title":"A2A Server","text":"Metric Before After Lines of code ~70 ~5 Reduction - 93%"},{"location":"benefits/#http-server","title":"HTTP Server","text":"Metric Before After Lines of code ~25 ~5 Reduction - 80%"},{"location":"benefits/#beyond-line-count","title":"Beyond Line Count","text":""},{"location":"benefits/#consistency","title":"Consistency","text":"<ul> <li>Same patterns across all agent projects</li> <li>Easier code reviews and onboarding</li> <li>Reduced cognitive load</li> </ul>"},{"location":"benefits/#security","title":"Security","text":"<ul> <li>VaultGuard integration built-in</li> <li>Secure credential management</li> <li>Security scoring and policies</li> </ul>"},{"location":"benefits/#observability","title":"Observability","text":"<ul> <li>OmniObserve hooks standardized</li> <li>Multiple providers (Opik, Langfuse, Phoenix)</li> <li>Consistent tracing across agents</li> </ul>"},{"location":"benefits/#deployment","title":"Deployment","text":"<ul> <li>Helm validation and templates</li> <li>Multi-runtime support (K8s, AgentCore)</li> <li>Write once, deploy anywhere</li> </ul>"},{"location":"benefits/#maintenance","title":"Maintenance","text":"<ul> <li>Single point of fixes</li> <li>Centralized security patches</li> <li>Clear version management</li> </ul>"},{"location":"benefits/#recommendation-matrix","title":"Recommendation Matrix","text":"Scenario Benefit Level Recommendation Single simple agent Low Optional Single complex agent system Medium Recommended 2-3 agent projects High Strongly Recommended 4+ agent projects Very High Essential Enterprise platform Critical Required"},{"location":"benefits/#roi-calculation","title":"ROI Calculation","text":"<p>Assuming: - Developer time: $100/hour - 1 line = 2 minutes to write/test/maintain</p> Projects Lines Saved Hours Saved Value 1 1,500 50 $5,000 5 7,500 250 $25,000 10 15,000 500 $50,000 <p>Plus ongoing maintenance savings from centralized bug fixes and updates.</p>"},{"location":"benefits/#conclusion","title":"Conclusion","text":"<p>AgentKit provides:</p> <ul> <li>29% code reduction per project</li> <li>Multiplicative savings across projects</li> <li>Consistency through standardized patterns</li> <li>Security via VaultGuard integration</li> <li>Multi-runtime deployment - Kubernetes or AWS AgentCore</li> </ul> <p>The value proposition strengthens significantly with scale. For organizations building multiple agent systems, AgentKit is essential infrastructure.</p>"},{"location":"migration/","title":"Migration Guide","text":"<p>Migrate existing agent projects to AgentKit.</p>"},{"location":"migration/#overview","title":"Overview","text":"<p>Migration typically involves:</p> <ol> <li>Adding the AgentKit dependency</li> <li>Replacing local <code>pkg/</code> imports with AgentKit imports</li> <li>Using server factories instead of manual setup</li> <li>Removing redundant local packages</li> </ol>"},{"location":"migration/#step-1-add-dependency","title":"Step 1: Add Dependency","text":"<pre><code>go get github.com/agentplexus/agentkit\n</code></pre>"},{"location":"migration/#step-2-replace-imports","title":"Step 2: Replace Imports","text":""},{"location":"migration/#configuration","title":"Configuration","text":"<pre><code>// Before\nimport \"github.com/myproject/pkg/config\"\n\n// After\nimport \"github.com/agentplexus/agentkit/config\"\n</code></pre>"},{"location":"migration/#llm","title":"LLM","text":"<pre><code>// Before\nimport \"github.com/myproject/pkg/llm\"\n\n// After\nimport \"github.com/agentplexus/agentkit/llm\"\n</code></pre>"},{"location":"migration/#agent","title":"Agent","text":"<pre><code>// Before\nimport \"github.com/myproject/pkg/agent\"\n\n// After\nimport \"github.com/agentplexus/agentkit/agent\"\n</code></pre>"},{"location":"migration/#http-client","title":"HTTP Client","text":"<pre><code>// Before\nimport \"github.com/myproject/pkg/httpclient\"\n\n// After\nimport \"github.com/agentplexus/agentkit/http\"\n</code></pre>"},{"location":"migration/#step-3-use-server-factories","title":"Step 3: Use Server Factories","text":""},{"location":"migration/#a2a-server","title":"A2A Server","text":"<pre><code>// Before (~70 lines)\nfunc startA2AServer(agent agent.Agent, port string) error {\n    listener, _ := net.Listen(\"tcp\", \"0.0.0.0:\"+port)\n    agentCard := &amp;a2a.AgentCard{...}\n    mux := http.NewServeMux()\n    // ... 50+ more lines\n}\n\n// After (~5 lines)\nimport \"github.com/agentplexus/agentkit/a2a\"\n\nserver, _ := a2a.NewServer(a2a.Config{\n    Agent: myAgent,\n    Port:  \"9001\",\n})\nserver.Start(ctx)\n</code></pre>"},{"location":"migration/#http-server","title":"HTTP Server","text":"<pre><code>// Before (~25 lines)\nserver := &amp;http.Server{\n    Addr:         \":8001\",\n    ReadTimeout:  30 * time.Second,\n    // ...\n}\nhttp.HandleFunc(\"/research\", handler)\nhttp.HandleFunc(\"/health\", healthHandler)\nserver.ListenAndServe()\n\n// After (~5 lines)\nimport \"github.com/agentplexus/agentkit/httpserver\"\n\nserver, _ := httpserver.NewBuilder(\"my-agent\", 8001).\n    WithHandlerFunc(\"/research\", handler).\n    Build()\nserver.Start()\n</code></pre>"},{"location":"migration/#step-4-remove-redundant-code","title":"Step 4: Remove Redundant Code","text":"<p>Delete your local packages that are now provided by AgentKit:</p> <pre><code>rm -rf pkg/config/\nrm -rf pkg/llm/\nrm -rf pkg/agent/\nrm -rf pkg/httpclient/\n</code></pre>"},{"location":"migration/#complete-example","title":"Complete Example","text":""},{"location":"migration/#before","title":"Before","text":"<pre><code>package main\n\nimport (\n    \"github.com/myproject/pkg/config\"\n    \"github.com/myproject/pkg/agent\"\n)\n\nfunc main() {\n    cfg := config.LoadConfig()\n\n    base, _ := agent.NewBaseAgent(cfg, 30)\n    defer base.Close()\n\n    researchAgent := NewResearchAgent(base, cfg)\n\n    // Manual HTTP server setup (~25 lines)\n    server := &amp;http.Server{...}\n    http.HandleFunc(\"/research\", researchAgent.HandleResearch)\n    http.HandleFunc(\"/health\", ...)\n\n    // Manual A2A server setup (~70 lines)\n    go func() {\n        listener, _ := net.Listen(...)\n        agentCard := &amp;a2a.AgentCard{...}\n        // ... many more lines\n    }()\n\n    server.ListenAndServe()\n}\n</code></pre>"},{"location":"migration/#after","title":"After","text":"<pre><code>package main\n\nimport (\n    \"github.com/agentplexus/agentkit/agent\"\n    \"github.com/agentplexus/agentkit/config\"\n    \"github.com/agentplexus/agentkit/a2a\"\n    \"github.com/agentplexus/agentkit/httpserver\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    cfg := config.LoadConfig()\n\n    base, _ := agent.NewBaseAgent(cfg, \"research-agent\", 30)\n    defer base.Close()\n\n    researchAgent := NewResearchAgent(base, cfg)\n\n    // HTTP server - 5 lines\n    httpServer, _ := httpserver.NewBuilder(\"research-agent\", 8001).\n        WithHandlerFunc(\"/research\", researchAgent.HandleResearch).\n        Build()\n\n    // A2A server - 5 lines\n    a2aServer, _ := a2a.NewServer(a2a.Config{\n        Agent: researchAgent.ADKAgent(),\n        Port:  \"9001\",\n    })\n\n    a2aServer.StartAsync(ctx)\n    httpServer.Start()\n}\n</code></pre>"},{"location":"migration/#migration-checklist","title":"Migration Checklist","text":"<ul> <li>[ ] Add AgentKit dependency</li> <li>[ ] Replace <code>pkg/config</code> with <code>agentkit/config</code></li> <li>[ ] Replace <code>pkg/llm</code> with <code>agentkit/llm</code></li> <li>[ ] Replace <code>pkg/agent</code> with <code>agentkit/agent</code></li> <li>[ ] Replace <code>pkg/httpclient</code> with <code>agentkit/http</code></li> <li>[ ] Replace manual A2A server with <code>a2a.NewServer()</code></li> <li>[ ] Replace manual HTTP server with <code>httpserver.NewBuilder()</code></li> <li>[ ] Remove redundant <code>pkg/</code> directories</li> <li>[ ] Update tests</li> <li>[ ] Verify all endpoints work</li> </ul>"},{"location":"migration/#estimated-savings","title":"Estimated Savings","text":"Component Lines Removed pkg/config ~140 lines pkg/llm ~200 lines pkg/agent ~140 lines pkg/httpclient ~90 lines A2A server boilerplate ~350 lines HTTP server boilerplate ~125 lines Total ~1,045 lines"},{"location":"migration/#gradual-migration","title":"Gradual Migration","text":"<p>You can migrate incrementally:</p> <ol> <li>Week 1: Replace <code>pkg/config</code> and <code>pkg/llm</code></li> <li>Week 2: Replace server boilerplate with factories</li> <li>Week 3: Replace remaining packages, remove old code</li> </ol> <p>Each step is independently testable.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Go 1.21 or later</li> <li>Access to at least one LLM provider (Gemini, Claude, OpenAI, xAI, or Ollama)</li> </ul>"},{"location":"getting-started/installation/#install-agentkit","title":"Install AgentKit","text":"<pre><code>go get github.com/agentplexus/agentkit\n</code></pre>"},{"location":"getting-started/installation/#import-packages","title":"Import Packages","text":"<p>Import the packages you need:</p> <pre><code>import (\n    \"github.com/agentplexus/agentkit/agent\"\n    \"github.com/agentplexus/agentkit/config\"\n    \"github.com/agentplexus/agentkit/llm\"\n    \"github.com/agentplexus/agentkit/orchestration\"\n    \"github.com/agentplexus/agentkit/a2a\"\n    \"github.com/agentplexus/agentkit/httpserver\"\n)\n</code></pre> <p>For platform-specific packages:</p> <pre><code>// Kubernetes + Helm\nimport \"github.com/agentplexus/agentkit/platforms/kubernetes\"\n\n// AWS AgentCore\nimport \"github.com/agentplexus/agentkit/platforms/agentcore\"\n</code></pre>"},{"location":"getting-started/installation/#environment-variables","title":"Environment Variables","text":"<p>Configure your LLM provider:</p> Variable Description Default <code>LLM_PROVIDER</code> Provider (gemini, claude, openai, xai, ollama) gemini <code>LLM_MODEL</code> Model name Provider default <code>GEMINI_API_KEY</code> Gemini API key - <code>CLAUDE_API_KEY</code> Claude/Anthropic API key - <code>OPENAI_API_KEY</code> OpenAI API key - <code>XAI_API_KEY</code> xAI API key - <code>OLLAMA_URL</code> Ollama server URL http://localhost:11434"},{"location":"getting-started/installation/#optional-observability","title":"Optional Observability","text":"Variable Description Default <code>OBSERVABILITY_ENABLED</code> Enable LLM observability false <code>OBSERVABILITY_PROVIDER</code> Provider (opik, langfuse, phoenix) opik"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Create a simple test file:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n\n    \"github.com/agentplexus/agentkit/agent\"\n    \"github.com/agentplexus/agentkit/config\"\n)\n\nfunc main() {\n    cfg := config.LoadConfig()\n\n    ba, err := agent.NewBaseAgent(cfg, \"test-agent\", 30)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer ba.Close()\n\n    log.Printf(\"AgentKit installed successfully!\")\n    log.Printf(\"Provider: %s\", ba.GetProviderInfo())\n}\n</code></pre> <p>Run it:</p> <pre><code>export LLM_PROVIDER=gemini\nexport GEMINI_API_KEY=your-api-key\ngo run main.go\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start - Build your first agent</li> <li>Local Development - Set up your development environment</li> </ul>"},{"location":"getting-started/local-development/","title":"Local Development","text":"<p>AgentKit is designed for seamless local development. The same code runs locally and in production - only the infrastructure differs.</p>"},{"location":"getting-started/local-development/#running-locally","title":"Running Locally","text":""},{"location":"getting-started/local-development/#http-server","title":"HTTP Server","text":"<pre><code>go run main.go\n</code></pre> <p>Test your endpoints:</p> <pre><code># Health check\ncurl http://localhost:8001/health\n\n# Your endpoint\ncurl -X POST http://localhost:8001/research \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"query\": \"test\"}'\n</code></pre>"},{"location":"getting-started/local-development/#a2a-server","title":"A2A Server","text":"<pre><code>go run main.go\n</code></pre> <p>Test the A2A endpoints:</p> <pre><code># Agent card\ncurl http://localhost:9001/.well-known/agent.json\n\n# Invoke\ncurl -X POST http://localhost:9001/invoke \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"method\": \"agent/run\", \"params\": {\"prompt\": \"test\"}}'\n</code></pre>"},{"location":"getting-started/local-development/#agentcore-runtime","title":"AgentCore Runtime","text":"<p>The AgentCore server runs locally with the same <code>/ping</code> and <code>/invocations</code> endpoints as production:</p> <pre><code>go run main.go\n</code></pre> <p>Test the endpoints:</p> <pre><code># Health check\ncurl http://localhost:8080/ping\n\n# Invoke agent\ncurl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"prompt\": \"Find statistics about AI adoption\"}'\n</code></pre>"},{"location":"getting-started/local-development/#local-vs-production","title":"Local vs Production","text":"<p>The code is identical - only the infrastructure changes:</p> Aspect Local Kubernetes AWS AgentCore Process Go binary Container Firecracker microVM Sessions In-memory Pod-based Isolated per microVM Scaling Manual HPA Automatic Startup Instant Container pull Cold start ~100ms"},{"location":"getting-started/local-development/#environment-setup","title":"Environment Setup","text":"<p>Create a <code>.env</code> file for local development:</p> <pre><code># LLM Provider\nLLM_PROVIDER=gemini\nGEMINI_API_KEY=your-api-key\n\n# Optional: Observability\nOBSERVABILITY_ENABLED=false\n\n# Optional: Search provider\nSEARCH_PROVIDER=serper\nSERPER_API_KEY=your-api-key\n</code></pre> <p>Load it:</p> <pre><code>source .env &amp;&amp; go run main.go\n</code></pre> <p>Or use a tool like direnv.</p>"},{"location":"getting-started/local-development/#hot-reload","title":"Hot Reload","text":"<p>For faster development iteration, use a tool like air:</p> <pre><code># Install\ngo install github.com/cosmtrek/air@latest\n\n# Run with hot reload\nair\n</code></pre> <p>Create <code>.air.toml</code>:</p> <pre><code>[build]\ncmd = \"go build -o ./tmp/main .\"\nbin = \"./tmp/main\"\ninclude_ext = [\"go\"]\nexclude_dir = [\"tmp\", \"vendor\"]\n</code></pre>"},{"location":"getting-started/local-development/#testing","title":"Testing","text":""},{"location":"getting-started/local-development/#unit-tests","title":"Unit Tests","text":"<pre><code>go test ./...\n</code></pre>"},{"location":"getting-started/local-development/#integration-tests","title":"Integration Tests","text":"<p>Test your agent endpoints:</p> <pre><code>func TestResearchEndpoint(t *testing.T) {\n    // Start server\n    server, _ := httpserver.NewBuilder(\"test-agent\", 0). // Port 0 = random\n        WithHandlerFunc(\"/research\", agent.HandleResearch).\n        Build()\n\n    server.StartAsync()\n    defer server.Stop(context.Background())\n\n    // Make request\n    resp, err := http.Post(\n        server.URL()+\"/research\",\n        \"application/json\",\n        strings.NewReader(`{\"query\": \"test\"}`),\n    )\n\n    // Assert\n    assert.NoError(t, err)\n    assert.Equal(t, 200, resp.StatusCode)\n}\n</code></pre>"},{"location":"getting-started/local-development/#a2a-server-testing","title":"A2A Server Testing","text":"<pre><code>func TestA2AServer(t *testing.T) {\n    server, _ := a2a.NewServer(a2a.Config{\n        Agent: myAgent,\n        Port:  \"\", // Random port\n    })\n\n    server.StartAsync(context.Background())\n    defer server.Stop(context.Background())\n\n    // Fetch agent card\n    resp, _ := http.Get(server.AgentCardURL())\n    assert.Equal(t, 200, resp.StatusCode)\n}\n</code></pre>"},{"location":"getting-started/local-development/#debugging","title":"Debugging","text":""},{"location":"getting-started/local-development/#enable-request-logging","title":"Enable Request Logging","text":"<pre><code>server, _ := httpserver.NewBuilder(\"my-agent\", 8001).\n    WithHandlerFunc(\"/research\", agent.HandleResearch).\n    WithDualModeLog(). // Logs startup info\n    Build()\n</code></pre>"},{"location":"getting-started/local-development/#verbose-llm-logging","title":"Verbose LLM Logging","text":"<p>Set the log level:</p> <pre><code>export LOG_LEVEL=debug\ngo run main.go\n</code></pre>"},{"location":"getting-started/local-development/#next-steps","title":"Next Steps","text":"<ul> <li>Kubernetes Deployment</li> <li>AWS AgentCore Deployment</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This guide walks you through creating a complete agent with both HTTP and A2A servers.</p>"},{"location":"getting-started/quick-start/#create-your-agent","title":"Create Your Agent","text":"<p>First, define your agent logic:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"net/http\"\n\n    \"github.com/agentplexus/agentkit/agent\"\n    \"github.com/agentplexus/agentkit/config\"\n)\n\ntype ResearchAgent struct {\n    base *agent.BaseAgent\n}\n\ntype ResearchRequest struct {\n    Query string `json:\"query\"`\n}\n\ntype ResearchResponse struct {\n    Results []string `json:\"results\"`\n}\n\nfunc NewResearchAgent(base *agent.BaseAgent) *ResearchAgent {\n    return &amp;ResearchAgent{base: base}\n}\n\nfunc (a *ResearchAgent) HandleResearch(w http.ResponseWriter, r *http.Request) {\n    var req ResearchRequest\n    if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n\n    // Your agent logic here\n    results := []string{\"Result 1\", \"Result 2\"}\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(ResearchResponse{Results: results})\n}\n</code></pre>"},{"location":"getting-started/quick-start/#add-http-server","title":"Add HTTP Server","text":"<p>Use the httpserver factory to expose your agent:</p> <pre><code>import \"github.com/agentplexus/agentkit/httpserver\"\n\nfunc main() {\n    cfg := config.LoadConfig()\n\n    base, _ := agent.NewBaseAgent(cfg, \"research-agent\", 30)\n    defer base.Close()\n\n    researchAgent := NewResearchAgent(base)\n\n    // Create HTTP server with builder pattern\n    server, _ := httpserver.NewBuilder(\"research-agent\", 8001).\n        WithHandlerFunc(\"/research\", researchAgent.HandleResearch).\n        WithDualModeLog().\n        Build()\n\n    server.Start()\n}\n</code></pre> <p>Test it:</p> <pre><code>curl -X POST http://localhost:8001/research \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"query\": \"test\"}'\n</code></pre>"},{"location":"getting-started/quick-start/#add-a2a-server","title":"Add A2A Server","text":"<p>For agent-to-agent communication, add an A2A server:</p> <pre><code>import (\n    \"github.com/agentplexus/agentkit/a2a\"\n    \"github.com/agentplexus/agentkit/httpserver\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    cfg := config.LoadConfig()\n\n    base, _ := agent.NewBaseAgent(cfg, \"research-agent\", 30)\n    defer base.Close()\n\n    researchAgent := NewResearchAgent(base)\n\n    // HTTP server\n    httpServer, _ := httpserver.NewBuilder(\"research-agent\", 8001).\n        WithHandlerFunc(\"/research\", researchAgent.HandleResearch).\n        Build()\n\n    // A2A server\n    a2aServer, _ := a2a.NewServer(a2a.Config{\n        Agent:       researchAgent.ADKAgent(),\n        Port:        \"9001\",\n        Description: \"Research agent for web search\",\n    })\n\n    // Start both\n    a2aServer.StartAsync(ctx)\n    httpServer.Start()\n}\n</code></pre>"},{"location":"getting-started/quick-start/#use-workflow-orchestration","title":"Use Workflow Orchestration","text":"<p>For complex multi-step workflows, use the orchestration package:</p> <pre><code>import (\n    \"github.com/cloudwego/eino/compose\"\n    \"github.com/agentplexus/agentkit/orchestration\"\n)\n\ntype WorkflowInput struct {\n    Query string\n}\n\ntype WorkflowOutput struct {\n    Result string\n}\n\nfunc main() {\n    // Build workflow graph\n    builder := orchestration.NewGraphBuilder[*WorkflowInput, *WorkflowOutput](\"research-workflow\")\n    graph := builder.Graph()\n\n    // Add processing node\n    processLambda := compose.InvokableLambda(func(ctx context.Context, input *WorkflowInput) (*WorkflowOutput, error) {\n        return &amp;WorkflowOutput{Result: \"Processed: \" + input.Query}, nil\n    })\n    graph.AddLambdaNode(\"process\", processLambda)\n\n    // Connect nodes\n    builder.AddStartEdge(\"process\")\n    builder.AddEndEdge(\"process\")\n\n    // Create executor\n    finalGraph := builder.Build()\n    executor := orchestration.NewExecutor(finalGraph, \"research-workflow\")\n\n    // Expose as HTTP handler\n    handler := orchestration.NewHTTPHandler(executor)\n\n    server, _ := httpserver.NewBuilder(\"research-agent\", 8001).\n        WithHandler(\"/research\", handler).\n        Build()\n\n    server.Start()\n}\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Local Development - Test locally before deploying</li> <li>A2A Server - Full A2A server documentation</li> <li>HTTP Server - HTTP server factory options</li> <li>Platforms - Deploy to Kubernetes or AWS AgentCore</li> </ul>"},{"location":"packages/agent/","title":"agent","text":"<p>Base agent implementation with LLM integration.</p>"},{"location":"packages/agent/#baseagent","title":"BaseAgent","text":"<pre><code>import (\n    \"github.com/agentplexus/agentkit/agent\"\n    \"github.com/agentplexus/agentkit/config\"\n)\n\ncfg := config.LoadConfig()\n\nba, err := agent.NewBaseAgent(cfg, \"my-agent\", 30) // 30 second timeout\nif err != nil {\n    log.Fatal(err)\n}\ndefer ba.Close()\n</code></pre>"},{"location":"packages/agent/#secure-agent","title":"Secure Agent","text":"<p>Create an agent with VaultGuard security checks:</p> <pre><code>ba, secCfg, err := agent.NewBaseAgentSecure(ctx, \"my-agent\", 30,\n    config.WithPolicy(nil), // Default policy\n)\nif err != nil {\n    log.Fatalf(\"Security check failed: %v\", err)\n}\ndefer ba.Close()\ndefer secCfg.Close()\n\n// Security info\nlog.Printf(\"Environment: %s\", secCfg.Environment())\nlog.Printf(\"Security score: %d\", secCfg.SecurityResult().Score)\n</code></pre>"},{"location":"packages/agent/#methods","title":"Methods","text":""},{"location":"packages/agent/#llm-operations","title":"LLM Operations","text":"<pre><code>// Get provider info\ninfo := ba.GetProviderInfo()\n\n// Generate response\nresponse, err := ba.Generate(ctx, prompt)\n</code></pre>"},{"location":"packages/agent/#http-operations","title":"HTTP Operations","text":"<pre><code>// Fetch URL content\ncontent, err := ba.FetchURL(ctx, \"https://example.com\", 10) // 10MB max\n</code></pre>"},{"location":"packages/agent/#logging","title":"Logging","text":"<pre><code>ba.LogInfo(\"Processing request: %s\", requestID)\nba.LogError(\"Failed to process: %v\", err)\nba.LogDebug(\"Debug info: %v\", data)\n</code></pre>"},{"location":"packages/agent/#building-custom-agents","title":"Building Custom Agents","text":"<p>Embed BaseAgent in your custom agent:</p> <pre><code>type ResearchAgent struct {\n    base *agent.BaseAgent\n    cfg  *config.Config\n}\n\nfunc NewResearchAgent(base *agent.BaseAgent, cfg *config.Config) *ResearchAgent {\n    return &amp;ResearchAgent{\n        base: base,\n        cfg:  cfg,\n    }\n}\n\nfunc (a *ResearchAgent) Research(ctx context.Context, query string) (*Result, error) {\n    // Use base agent's LLM\n    response, err := a.base.Generate(ctx, query)\n    if err != nil {\n        a.base.LogError(\"Research failed: %v\", err)\n        return nil, err\n    }\n\n    a.base.LogInfo(\"Research completed for: %s\", query)\n    return &amp;Result{Content: response}, nil\n}\n</code></pre>"},{"location":"packages/agent/#http-handler-pattern","title":"HTTP Handler Pattern","text":"<pre><code>func (a *ResearchAgent) HandleResearch(w http.ResponseWriter, r *http.Request) {\n    var req ResearchRequest\n    if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n\n    result, err := a.Research(r.Context(), req.Query)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(result)\n}\n</code></pre>"},{"location":"packages/agent/#google-adk-integration","title":"Google ADK Integration","text":"<p>Wrap your agent for A2A protocol:</p> <pre><code>func (a *ResearchAgent) ADKAgent() agent.Agent {\n    // Return Google ADK agent implementation\n    return a.adkAgent\n}\n</code></pre> <p>Use with A2A server:</p> <pre><code>a2aServer, _ := a2a.NewServer(a2a.Config{\n    Agent: researchAgent.ADKAgent(),\n    Port:  \"9001\",\n})\n</code></pre>"},{"location":"packages/config/","title":"config","text":"<p>Configuration management with optional VaultGuard security integration.</p>"},{"location":"packages/config/#basic-configuration","title":"Basic Configuration","text":"<pre><code>import \"github.com/agentplexus/agentkit/config\"\n\ncfg := config.LoadConfig()\n\n// Access values\nprovider := cfg.LLMProvider\nmodel := cfg.LLMModel\n</code></pre>"},{"location":"packages/config/#environment-variables","title":"Environment Variables","text":"Variable Description Default <code>LLM_PROVIDER</code> Provider (gemini, claude, openai, xai, ollama) gemini <code>LLM_MODEL</code> Model name Provider default <code>GEMINI_API_KEY</code> Gemini API key - <code>CLAUDE_API_KEY</code> Claude/Anthropic API key - <code>OPENAI_API_KEY</code> OpenAI API key - <code>XAI_API_KEY</code> xAI API key - <code>OLLAMA_URL</code> Ollama server URL http://localhost:11434 <code>OBSERVABILITY_ENABLED</code> Enable observability false <code>OBSERVABILITY_PROVIDER</code> Provider (opik, langfuse, phoenix) opik"},{"location":"packages/config/#secure-configuration","title":"Secure Configuration","text":"<p>Use VaultGuard for production credential management:</p> <pre><code>import \"github.com/agentplexus/agentkit/config\"\n\n// Load with security checks\nsecCfg, err := config.LoadSecureConfig(ctx,\n    config.WithPolicy(nil), // Default policy\n)\nif err != nil {\n    log.Fatalf(\"Security check failed: %v\", err)\n}\ndefer secCfg.Close()\n\n// Check security score\nresult := secCfg.SecurityResult()\nlog.Printf(\"Security score: %d\", result.Score)\nlog.Printf(\"Environment: %s\", secCfg.Environment())\n\n// Get credentials securely\napiKey, err := secCfg.GetCredential(ctx, \"GEMINI_API_KEY\")\n</code></pre>"},{"location":"packages/config/#security-policies","title":"Security Policies","text":"<pre><code>// Development policy (relaxed)\nsecCfg, _ := config.LoadSecureConfig(ctx, config.WithDevPolicy())\n\n// Strict policy\nsecCfg, _ := config.LoadSecureConfig(ctx, config.WithStrictPolicy())\n\n// Custom policy\npolicy := &amp;vaultguard.Policy{\n    MinSecurityScore:  70,\n    RequireEncryption: true,\n    RequireIAM:        true,\n}\nsecCfg, _ := config.LoadSecureConfig(ctx, config.WithPolicy(policy))\n</code></pre>"},{"location":"packages/config/#config-struct","title":"Config Struct","text":"<pre><code>type Config struct {\n    // LLM\n    LLMProvider string\n    LLMModel    string\n\n    // API Keys (from environment)\n    GeminiAPIKey  string\n    ClaudeAPIKey  string\n    OpenAIAPIKey  string\n    XAIAPIKey     string\n    OllamaURL     string\n\n    // Observability\n    ObservabilityEnabled  bool\n    ObservabilityProvider string\n\n    // Search\n    SearchProvider string\n    SerperAPIKey   string\n    SerpAPIKey     string\n}\n</code></pre>"},{"location":"packages/config/#usage-with-baseagent","title":"Usage with BaseAgent","text":"<pre><code>cfg := config.LoadConfig()\n\n// Config is passed to BaseAgent\nba, err := agent.NewBaseAgent(cfg, \"my-agent\", 30)\n</code></pre>"},{"location":"packages/config/#secure-baseagent","title":"Secure BaseAgent","text":"<pre><code>// Creates agent with security checks\nba, secCfg, err := agent.NewBaseAgentSecure(ctx, \"my-agent\", 30,\n    config.WithPolicy(nil),\n)\nif err != nil {\n    log.Fatalf(\"Security check failed: %v\", err)\n}\ndefer ba.Close()\ndefer secCfg.Close()\n</code></pre>"},{"location":"packages/http/","title":"http","text":"<p>HTTP client utilities for inter-agent communication.</p>"},{"location":"packages/http/#json-requests","title":"JSON Requests","text":""},{"location":"packages/http/#post-json","title":"POST JSON","text":"<pre><code>import \"github.com/agentplexus/agentkit/http\"\n\nclient := &amp;http.Client{Timeout: 30 * time.Second}\n\nrequest := MyRequest{Query: \"test\"}\nvar response MyResponse\n\nerr := http.PostJSON(ctx, client, \"http://agent:8001/process\", request, &amp;response)\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre>"},{"location":"packages/http/#get-json","title":"GET JSON","text":"<pre><code>var response MyResponse\nerr := http.GetJSON(ctx, client, \"http://agent:8001/data\", &amp;response)\n</code></pre>"},{"location":"packages/http/#health-checks","title":"Health Checks","text":"<pre><code>err := http.HealthCheck(ctx, client, \"http://agent:8001\")\nif err != nil {\n    log.Printf(\"Agent unhealthy: %v\", err)\n}\n</code></pre>"},{"location":"packages/http/#error-handling","title":"Error Handling","text":"<p>The functions return wrapped errors with context:</p> <pre><code>err := http.PostJSON(ctx, client, url, req, &amp;resp)\nif err != nil {\n    // Error includes URL and status code\n    // \"POST http://agent:8001/process failed: 500 Internal Server Error\"\n    log.Printf(\"Request failed: %v\", err)\n}\n</code></pre>"},{"location":"packages/http/#retry-logic","title":"Retry Logic","text":"<p>For production, wrap with retry logic:</p> <pre><code>import \"github.com/avast/retry-go\"\n\nerr := retry.Do(\n    func() error {\n        return http.PostJSON(ctx, client, url, req, &amp;resp)\n    },\n    retry.Attempts(3),\n    retry.Delay(time.Second),\n    retry.DelayType(retry.BackOffDelay),\n)\n</code></pre>"},{"location":"packages/http/#usage-in-orchestration","title":"Usage in Orchestration","text":"<pre><code>import (\n    agenthttp \"github.com/agentplexus/agentkit/http\"\n    \"github.com/agentplexus/agentkit/orchestration\"\n)\n\n// In a workflow node\nresearchLambda := compose.InvokableLambda(func(ctx context.Context, input *Input) (*Output, error) {\n    client := &amp;http.Client{Timeout: 30 * time.Second}\n\n    var resp ResearchResponse\n    err := agenthttp.PostJSON(ctx, client,\n        \"http://research-agent:8001/research\",\n        ResearchRequest{Query: input.Query},\n        &amp;resp,\n    )\n    if err != nil {\n        return nil, fmt.Errorf(\"research call failed: %w\", err)\n    }\n\n    return &amp;Output{Result: resp.Result}, nil\n})\n</code></pre>"},{"location":"packages/http/#custom-headers","title":"Custom Headers","text":"<p>For requests needing custom headers, use the standard http package:</p> <pre><code>import \"net/http\"\n\nreq, _ := http.NewRequestWithContext(ctx, \"POST\", url, body)\nreq.Header.Set(\"Authorization\", \"Bearer \"+token)\nreq.Header.Set(\"Content-Type\", \"application/json\")\n\nresp, err := client.Do(req)\n</code></pre>"},{"location":"packages/llm/","title":"llm","text":"<p>Multi-provider LLM abstraction via OmniLLM.</p>"},{"location":"packages/llm/#model-factory","title":"Model Factory","text":"<pre><code>import \"github.com/agentplexus/agentkit/llm\"\n\ncfg := config.LoadConfig()\n\nfactory := llm.NewModelFactory(cfg)\nmodel, err := factory.CreateModel(ctx)\nif err != nil {\n    log.Fatal(err)\n}\ndefer factory.Close()\n</code></pre>"},{"location":"packages/llm/#supported-providers","title":"Supported Providers","text":"Provider Environment Variables Gemini <code>GEMINI_API_KEY</code>, <code>LLM_MODEL</code> Claude <code>CLAUDE_API_KEY</code>, <code>LLM_MODEL</code> OpenAI <code>OPENAI_API_KEY</code>, <code>LLM_MODEL</code> xAI <code>XAI_API_KEY</code>, <code>LLM_MODEL</code> Ollama <code>OLLAMA_URL</code>, <code>LLM_MODEL</code>"},{"location":"packages/llm/#provider-selection","title":"Provider Selection","text":"<p>Set via environment:</p> <pre><code>export LLM_PROVIDER=gemini\nexport GEMINI_API_KEY=your-key\nexport LLM_MODEL=gemini-2.0-flash-exp\n</code></pre> <p>Or in code:</p> <pre><code>cfg := config.LoadConfig()\ncfg.LLMProvider = \"claude\"\ncfg.LLMModel = \"claude-3-5-sonnet-20241022\"\n\nfactory := llm.NewModelFactory(cfg)\n</code></pre>"},{"location":"packages/llm/#model-interface","title":"Model Interface","text":"<p>The factory returns an OmniLLM model that implements a standard interface:</p> <pre><code>model, _ := factory.CreateModel(ctx)\n\n// Generate text\nresponse, err := model.Generate(ctx, prompt)\n\n// Chat completion\nmessages := []Message{\n    {Role: \"user\", Content: \"Hello\"},\n}\nresponse, err := model.Chat(ctx, messages)\n</code></pre>"},{"location":"packages/llm/#observability","title":"Observability","text":"<p>Enable LLM observability with OmniObserve:</p> <pre><code>export OBSERVABILITY_ENABLED=true\nexport OBSERVABILITY_PROVIDER=opik  # or langfuse, phoenix\n</code></pre> <pre><code>cfg := config.LoadConfig()\n// Observability is automatically configured\nfactory := llm.NewModelFactory(cfg)\n</code></pre>"},{"location":"packages/llm/#adapters","title":"Adapters","text":"<p>The <code>llm/adapters</code> package provides adapters for specific frameworks:</p> <pre><code>import \"github.com/agentplexus/agentkit/llm/adapters\"\n\n// Eino adapter\neinoModel := adapters.NewEinoAdapter(model)\n\n// ADK adapter\nadkModel := adapters.NewADKAdapter(model)\n</code></pre>"},{"location":"packages/llm/#usage-with-baseagent","title":"Usage with BaseAgent","text":"<p>The BaseAgent automatically creates and manages the LLM:</p> <pre><code>ba, _ := agent.NewBaseAgent(cfg, \"my-agent\", 30)\n\n// LLM is available via base agent\nresponse, err := ba.Generate(ctx, prompt)\n</code></pre>"},{"location":"packages/orchestration/","title":"orchestration","text":"<p>Eino-based workflow orchestration for multi-step agent workflows.</p>"},{"location":"packages/orchestration/#graph-builder","title":"Graph Builder","text":"<p>Create type-safe workflow graphs:</p> <pre><code>import (\n    \"github.com/cloudwego/eino/compose\"\n    \"github.com/agentplexus/agentkit/orchestration\"\n)\n\ntype Input struct {\n    Query string\n}\n\ntype Output struct {\n    Result string\n}\n\n// Create builder\nbuilder := orchestration.NewGraphBuilder[*Input, *Output](\"my-workflow\")\ngraph := builder.Graph()\n</code></pre>"},{"location":"packages/orchestration/#adding-nodes","title":"Adding Nodes","text":"<p>Use Eino's InvokableLambda for processing nodes:</p> <pre><code>// Processing node\nprocessLambda := compose.InvokableLambda(func(ctx context.Context, input *Input) (*Intermediate, error) {\n    return &amp;Intermediate{Data: input.Query}, nil\n})\ngraph.AddLambdaNode(\"process\", processLambda)\n\n// Formatting node\nformatLambda := compose.InvokableLambda(func(ctx context.Context, data *Intermediate) (*Output, error) {\n    return &amp;Output{Result: data.Data}, nil\n})\ngraph.AddLambdaNode(\"format\", formatLambda)\n</code></pre>"},{"location":"packages/orchestration/#connecting-nodes","title":"Connecting Nodes","text":"<pre><code>// Start -&gt; process\nbuilder.AddStartEdge(\"process\")\n\n// process -&gt; format\nbuilder.AddEdge(\"process\", \"format\")\n\n// format -&gt; End\nbuilder.AddEndEdge(\"format\")\n</code></pre>"},{"location":"packages/orchestration/#building-and-executing","title":"Building and Executing","text":"<pre><code>// Build the graph\nfinalGraph := builder.Build()\n\n// Create executor\nexecutor := orchestration.NewExecutor(finalGraph, \"my-workflow\")\n\n// Execute\nresult, err := executor.Execute(ctx, &amp;Input{Query: \"test\"})\nif err != nil {\n    log.Fatal(err)\n}\nlog.Printf(\"Result: %s\", result.Result)\n</code></pre>"},{"location":"packages/orchestration/#http-handler","title":"HTTP Handler","text":"<p>Expose workflows as HTTP endpoints:</p> <pre><code>executor := orchestration.NewExecutor(graph, \"my-workflow\")\n\n// Create HTTP handler (handles JSON encode/decode, errors)\nhandler := orchestration.NewHTTPHandler(executor)\n\n// Use with httpserver\nserver, _ := httpserver.NewBuilder(\"my-agent\", 8001).\n    WithHandler(\"/workflow\", handler).\n    Build()\n</code></pre>"},{"location":"packages/orchestration/#agent-caller","title":"Agent Caller","text":"<p>Call other agents from within workflows:</p> <pre><code>import \"github.com/agentplexus/agentkit/orchestration\"\n\ncaller := orchestration.NewAgentCaller(httpClient)\n\n// Call another agent\nresponse, err := caller.Call(ctx, \"http://research-agent:8001/research\", request)\n</code></pre>"},{"location":"packages/orchestration/#multi-step-workflow-example","title":"Multi-Step Workflow Example","text":"<pre><code>type ResearchInput struct {\n    Topic string\n}\n\ntype ResearchOutput struct {\n    Summary string\n    Sources []string\n}\n\ntype IntermediateState struct {\n    Topic    string\n    Findings []string\n    Verified []string\n}\n\nfunc buildWorkflow() *orchestration.Executor[*ResearchInput, *ResearchOutput] {\n    builder := orchestration.NewGraphBuilder[*ResearchInput, *ResearchOutput](\"research\")\n    graph := builder.Graph()\n\n    // Research step\n    researchLambda := compose.InvokableLambda(func(ctx context.Context, input *ResearchInput) (*IntermediateState, error) {\n        // Call research agent\n        findings := doResearch(ctx, input.Topic)\n        return &amp;IntermediateState{\n            Topic:    input.Topic,\n            Findings: findings,\n        }, nil\n    })\n    graph.AddLambdaNode(\"research\", researchLambda)\n\n    // Verification step\n    verifyLambda := compose.InvokableLambda(func(ctx context.Context, state *IntermediateState) (*IntermediateState, error) {\n        // Verify findings\n        verified := verifyFindings(ctx, state.Findings)\n        state.Verified = verified\n        return state, nil\n    })\n    graph.AddLambdaNode(\"verify\", verifyLambda)\n\n    // Synthesis step\n    synthesizeLambda := compose.InvokableLambda(func(ctx context.Context, state *IntermediateState) (*ResearchOutput, error) {\n        summary := synthesize(ctx, state.Verified)\n        return &amp;ResearchOutput{\n            Summary: summary,\n            Sources: state.Verified,\n        }, nil\n    })\n    graph.AddLambdaNode(\"synthesize\", synthesizeLambda)\n\n    // Connect\n    builder.AddStartEdge(\"research\")\n    builder.AddEdge(\"research\", \"verify\")\n    builder.AddEdge(\"verify\", \"synthesize\")\n    builder.AddEndEdge(\"synthesize\")\n\n    return orchestration.NewExecutor(builder.Build(), \"research\")\n}\n</code></pre>"},{"location":"packages/orchestration/#conditional-branching","title":"Conditional Branching","text":"<pre><code>// Add branch node\ngraph.AddBranch(\"router\", func(ctx context.Context, input *Input) (string, error) {\n    if input.NeedsVerification {\n        return \"verify\", nil\n    }\n    return \"synthesize\", nil\n})\n\nbuilder.AddStartEdge(\"router\")\nbuilder.AddEdge(\"router\", \"verify\")\nbuilder.AddEdge(\"router\", \"synthesize\")\nbuilder.AddEdge(\"verify\", \"synthesize\")\nbuilder.AddEndEdge(\"synthesize\")\n</code></pre>"},{"location":"packages/orchestration/#error-handling","title":"Error Handling","text":"<p>Errors propagate through the workflow:</p> <pre><code>processLambda := compose.InvokableLambda(func(ctx context.Context, input *Input) (*Output, error) {\n    if input.Query == \"\" {\n        return nil, fmt.Errorf(\"empty query\")\n    }\n    // ...\n})\n\n// HTTPHandler returns 500 with error message\nhandler := orchestration.NewHTTPHandler(executor)\n</code></pre>"},{"location":"platforms/","title":"Platforms","text":"<p>AgentKit supports multiple deployment platforms. Your agent code is platform-agnostic - only the server bootstrap differs.</p>"},{"location":"platforms/#supported-platforms","title":"Supported Platforms","text":""},{"location":"platforms/#kubernetes","title":"Kubernetes","text":"<p>Traditional container-based deployment with Helm charts.</p> <ul> <li>Any K8s distribution (EKS, GKE, AKS, Minikube, kind, k3s)</li> <li>Container orchestration with HPA</li> <li>Helm-based configuration</li> <li>Always-on pricing</li> </ul>"},{"location":"platforms/#aws-agentcore","title":"AWS AgentCore","text":"<p>AWS Bedrock's serverless agent runtime.</p> <ul> <li>Firecracker microVM isolation</li> <li>Automatic scaling from zero</li> <li>Pay-per-use pricing</li> <li>Built-in session management</li> </ul>"},{"location":"platforms/#platform-comparison","title":"Platform Comparison","text":"Aspect Kubernetes AWS AgentCore Infrastructure K8s manifests AWS serverless Config tool Helm CDK / Terraform Scaling HPA Automatic Isolation Containers Firecracker microVMs Pricing Always-on Pay-per-use Session handling Application-managed Built-in"},{"location":"platforms/#same-code-different-runtimes","title":"Same Code, Different Runtimes","text":"<p>The key benefit: your agent implementation is runtime-agnostic.</p> <pre><code>// Agent implementation - works on any platform\nexecutor := orchestration.NewExecutor(graph, \"stats\")\n</code></pre>"},{"location":"platforms/#kubernetes-deployment","title":"Kubernetes Deployment","text":"<pre><code>import \"github.com/agentplexus/agentkit/httpserver\"\n\nhttpServer, _ := httpserver.NewBuilder(\"stats\", 8001).\n    WithHandler(\"/stats\", orchestration.NewHTTPHandler(executor)).\n    Build()\n\nhttpServer.Start()\n</code></pre>"},{"location":"platforms/#aws-agentcore-deployment","title":"AWS AgentCore Deployment","text":"<pre><code>import \"github.com/agentplexus/agentkit/platforms/agentcore\"\n\nacServer := agentcore.NewBuilder().\n    WithAgent(agentcore.WrapExecutor(\"stats\", executor)).\n    MustBuild(ctx)\n\nacServer.Start()\n</code></pre>"},{"location":"platforms/#choosing-a-platform","title":"Choosing a Platform","text":"Scenario Recommendation Existing K8s infrastructure Kubernetes AWS-native, pay-per-use AgentCore Need microVM isolation AgentCore Long-running agents Kubernetes Bursty, session-based workloads AgentCore Multi-cloud Kubernetes"},{"location":"platforms/#local-development","title":"Local Development","text":"<p>Both platforms support the same local development workflow:</p> <pre><code>go run main.go\ncurl localhost:8080/ping\ncurl -X POST localhost:8080/invocations -d '{\"prompt\":\"test\"}'\n</code></pre> <p>The code runs locally as a regular Go process. Only production deployment differs.</p>"},{"location":"platforms/#next-steps","title":"Next Steps","text":"<ul> <li>Kubernetes Deployment</li> <li>AWS AgentCore Deployment</li> </ul>"},{"location":"platforms/agentcore/","title":"AWS AgentCore Deployment","text":"<p>Deploy AgentKit agents to AWS Bedrock AgentCore - a serverless agent runtime powered by Firecracker microVMs.</p>"},{"location":"platforms/agentcore/#overview","title":"Overview","text":"<p>AWS AgentCore provides:</p> <ul> <li>Firecracker microVM isolation - Each session runs in its own microVM</li> <li>Serverless scaling - Automatic scaling from zero</li> <li>Pay-per-use pricing - Only pay for active CPU time</li> <li>Built-in session management - 8-hour sessions with automatic cleanup</li> </ul>"},{"location":"platforms/agentcore/#basic-setup","title":"Basic Setup","text":"<pre><code>import \"github.com/agentplexus/agentkit/platforms/agentcore\"\n\nserver := agentcore.NewBuilder().\n    WithPort(8080).\n    WithAgent(myAgent).\n    MustBuild(ctx)\n\nserver.Start()\n</code></pre>"},{"location":"platforms/agentcore/#builder-pattern","title":"Builder Pattern","text":"<pre><code>server := agentcore.NewBuilder().\n    WithPort(8080).                      // Default: 8080\n    WithAgent(researchAgent).            // Add agent\n    WithAgent(synthesisAgent).           // Add another\n    WithDefaultAgent(\"research\").        // Default for routing\n    WithRequestLogging(true).            // Enable logging\n    WithSessionTracking(true).           // Enable sessions\n    MustBuild(ctx)\n</code></pre>"},{"location":"platforms/agentcore/#configuration-options","title":"Configuration Options","text":"<pre><code>server := agentcore.NewServer(agentcore.Config{\n    Port:                  8080,\n    ReadTimeout:           30 * time.Second,\n    WriteTimeout:          300 * time.Second,  // 5 min for long operations\n    DefaultAgent:          \"research\",\n    EnableRequestLogging:  true,\n    EnableSessionTracking: true,\n})\n</code></pre>"},{"location":"platforms/agentcore/#endpoints","title":"Endpoints","text":"<p>AgentCore servers provide:</p> Endpoint Description <code>/ping</code> Health check <code>/invocations</code> Agent invocation"},{"location":"platforms/agentcore/#wrapping-eino-executors","title":"Wrapping Eino Executors","text":"<p>Wrap your Eino workflow executors for AgentCore:</p> <pre><code>import (\n    \"github.com/agentplexus/agentkit/orchestration\"\n    \"github.com/agentplexus/agentkit/platforms/agentcore\"\n)\n\n// Build Eino workflow\ngraph := buildOrchestrationGraph()\nexecutor := orchestration.NewExecutor(graph, \"stats-workflow\")\n\n// Simple wrap - uses JSON marshaling\nagent := agentcore.WrapExecutor(\"stats\", executor)\n\n// Custom I/O transformation\nagent := agentcore.WrapExecutorWithPrompt(\"stats\", executor,\n    func(prompt string) StatsRequest {\n        return StatsRequest{Topic: prompt}\n    },\n    func(output StatsResponse) string {\n        return output.Summary\n    },\n)\n</code></pre>"},{"location":"platforms/agentcore/#multi-agent-routing","title":"Multi-Agent Routing","text":"<p>Register multiple agents with automatic routing:</p> <pre><code>server := agentcore.NewBuilder().\n    WithAgent(researchAgent).\n    WithAgent(synthesisAgent).\n    WithAgent(verificationAgent).\n    WithDefaultAgent(\"research\").\n    MustBuild(ctx)\n</code></pre> <p>Invoke specific agents:</p> <pre><code># Default agent\ncurl -X POST localhost:8080/invocations \\\n  -d '{\"prompt\": \"Find AI statistics\"}'\n\n# Specific agent\ncurl -X POST localhost:8080/invocations \\\n  -d '{\"prompt\": \"Verify this claim\", \"agent\": \"verification\"}'\n</code></pre>"},{"location":"platforms/agentcore/#requestresponse-format","title":"Request/Response Format","text":""},{"location":"platforms/agentcore/#request","title":"Request","text":"<pre><code>{\n  \"prompt\": \"Find statistics about AI adoption\",\n  \"session_id\": \"optional-session-id\",\n  \"agent\": \"optional-agent-name\",\n  \"metadata\": {\n    \"key\": \"value\"\n  }\n}\n</code></pre>"},{"location":"platforms/agentcore/#response","title":"Response","text":"<pre><code>{\n  \"output\": \"Response from the agent...\",\n  \"session_id\": \"session-123\",\n  \"agent\": \"research\",\n  \"metadata\": {}\n}\n</code></pre>"},{"location":"platforms/agentcore/#session-management","title":"Session Management","text":"<p>AgentCore provides built-in session isolation:</p> <pre><code>// Access session in your agent\nfunc (a *MyAgent) Invoke(ctx context.Context, req agentcore.Request) (agentcore.Response, error) {\n    session := agentcore.SessionFromContext(ctx)\n\n    // Session info\n    sessionID := session.ID\n    startTime := session.StartTime\n\n    // Your logic...\n}\n</code></pre>"},{"location":"platforms/agentcore/#local-development","title":"Local Development","text":"<p>The same code runs locally - no AWS required for development:</p> <pre><code># Run locally\ngo run main.go\n\n# Test\ncurl localhost:8080/ping\ncurl -X POST localhost:8080/invocations -d '{\"prompt\":\"test\"}'\n</code></pre> Aspect Local AWS AgentCore Process Go binary Firecracker microVM Sessions In-memory Isolated per microVM Scaling Manual Automatic Startup Instant ~100ms cold start"},{"location":"platforms/agentcore/#aws-deployment","title":"AWS Deployment","text":"<p>Infrastructure as Code</p> <p>Helm does NOT apply to AgentCore. Use AWS CDK or Terraform instead.</p>"},{"location":"platforms/agentcore/#dockerfile","title":"Dockerfile","text":"<pre><code>FROM golang:1.21 AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 go build -o /agent ./cmd/agent\n\nFROM gcr.io/distroless/static\nCOPY --from=builder /agent /agent\nEXPOSE 8080\nCMD [\"/agent\"]\n</code></pre>"},{"location":"platforms/agentcore/#cdk-example","title":"CDK Example","text":"<pre><code>import * as agentcore from '@aws-cdk/aws-bedrock-agentcore';\n\nconst agent = new agentcore.Agent(this, 'StatsAgent', {\n  runtime: agentcore.Runtime.GO_1_21,\n  code: agentcore.Code.fromAsset('./'),\n  handler: 'main',\n  memory: 512,\n  timeout: Duration.minutes(5),\n});\n</code></pre>"},{"location":"platforms/agentcore/#kubernetes-vs-agentcore","title":"Kubernetes vs AgentCore","text":"Aspect Kubernetes AgentCore Infrastructure K8s manifests AWS-managed Config tool Helm CDK / Terraform Scaling HPA Automatic Isolation Containers Firecracker microVMs Pricing Always-on Pay-per-use Session handling Application Built-in"},{"location":"platforms/agentcore/#best-practices","title":"Best Practices","text":"<ol> <li>Use WrapExecutorWithPrompt for type-safe I/O transformation</li> <li>Set appropriate timeouts - AgentCore sessions can last up to 8 hours</li> <li>Use session tracking for multi-turn conversations</li> <li>Test locally first - Same code, same endpoints</li> </ol>"},{"location":"platforms/agentcore/#next-steps","title":"Next Steps","text":"<ul> <li>Kubernetes Deployment - Alternative container-based deployment</li> <li>Local Development - Test before deploying</li> </ul>"},{"location":"platforms/kubernetes/","title":"Kubernetes Deployment","text":"<p>Deploy AgentKit agents to Kubernetes using Helm charts.</p>"},{"location":"platforms/kubernetes/#supported-distributions","title":"Supported Distributions","text":"<p>AgentKit works with any Kubernetes distribution:</p> Type Distributions Cloud AWS EKS, Google GKE, Azure AKS, DigitalOcean DOKS Local Minikube, kind, k3s, Docker Desktop On-prem Rancher, OpenShift, Tanzu <p>The Helm charts and values validation are distribution-agnostic.</p>"},{"location":"platforms/kubernetes/#overview","title":"Overview","text":"<p>AgentKit provides:</p> <ul> <li>Helm values validation - Go structs with type-safe validation</li> <li>Reusable templates - Common deployment patterns</li> <li>Multi-agent support - Deploy multiple agents in one chart</li> </ul>"},{"location":"platforms/kubernetes/#helm-values-validation","title":"Helm Values Validation","text":"<p>Use the <code>platforms/kubernetes</code> package to validate your Helm values:</p> <pre><code>import \"github.com/agentplexus/agentkit/platforms/kubernetes\"\n\n// Load and validate\nvalues, errs := kubernetes.LoadAndValidate(\"values.yaml\")\nif len(errs) &gt; 0 {\n    for _, err := range errs {\n        log.Printf(\"Validation error: %v\", err)\n    }\n}\n\n// Merge base and overlay\nvalues, err := kubernetes.LoadAndMerge(\"values.yaml\", \"values-prod.yaml\")\n</code></pre>"},{"location":"platforms/kubernetes/#example-valuesyaml","title":"Example values.yaml","text":"<pre><code>global:\n  image:\n    registry: ghcr.io/myorg\n    pullPolicy: IfNotPresent\n    tag: \"latest\"\n\nnamespace:\n  create: true\n  name: my-agents\n\nllm:\n  provider: gemini\n  geminiModel: \"gemini-2.0-flash-exp\"\n\nagents:\n  research:\n    enabled: true\n    replicaCount: 2\n    image:\n      repository: research-agent\n    service:\n      type: ClusterIP\n      port: 8001\n      a2aPort: 9001\n    resources:\n      requests:\n        cpu: 100m\n        memory: 128Mi\n      limits:\n        cpu: 500m\n        memory: 512Mi\n    autoscaling:\n      enabled: true\n      minReplicas: 2\n      maxReplicas: 10\n      targetCPUUtilizationPercentage: 70\n\n  synthesis:\n    enabled: true\n    replicaCount: 1\n    image:\n      repository: synthesis-agent\n    service:\n      port: 8002\n      a2aPort: 9002\n\nsecrets:\n  create: true\n  geminiApiKey: \"\"  # Set via --set or external secret manager\n\nvaultguard:\n  enabled: true\n  minSecurityScore: 50\n  requireEncryption: true\n\ningress:\n  enabled: true\n  className: nginx\n  host: agents.example.com\n  tls:\n    - secretName: agents-tls\n      hosts:\n        - agents.example.com\n</code></pre>"},{"location":"platforms/kubernetes/#helm-templates","title":"Helm Templates","text":"<p>AgentKit provides reusable templates in <code>platforms/kubernetes/templates/</code>:</p>"},{"location":"platforms/kubernetes/#_helperstpl","title":"_helpers.tpl","text":"<p>Common template functions:</p> <pre><code># Agent labels\n{{- include \"agentkit.agentLabels\" (dict \"context\" . \"agent\" \"research\") }}\n\n# Image name\n{{- include \"agentkit.image\" (dict \"global\" .Values.global \"agent\" .Values.agents.research) }}\n\n# Namespace\n{{- include \"agentkit.namespace\" . }}\n</code></pre>"},{"location":"platforms/kubernetes/#deploymentyamltpl","title":"deployment.yaml.tpl","text":"<p>Generic deployment template:</p> <pre><code># In your chart's templates/research-deployment.yaml\n{{- include \"agentkit.deployment\" (dict \"agent\" .Values.agents.research \"name\" \"research\" \"values\" .) }}\n</code></pre>"},{"location":"platforms/kubernetes/#validation-rules","title":"Validation Rules","text":"<p>The Kubernetes package validates:</p> Field Validation <code>namespace.name</code> Required, 1-63 chars <code>llm.provider</code> One of: gemini, claude, openai, ollama, xai <code>agents.*.replicaCount</code> 0-100 <code>agents.*.service.port</code> 1-65535, no conflicts <code>resources.*.cpu</code> Valid K8s quantity (e.g., \"100m\", \"1\") <code>resources.*.memory</code> Valid K8s quantity (e.g., \"128Mi\", \"1Gi\") <code>ingress.host</code> Valid hostname when ingress enabled"},{"location":"platforms/kubernetes/#port-conflict-detection","title":"Port Conflict Detection","text":"<pre><code>values, errs := kubernetes.LoadAndValidate(\"values.yaml\")\n// Returns error if two agents use the same port:\n// \"port conflict: research and synthesis both use port 8001\"\n</code></pre>"},{"location":"platforms/kubernetes/#deployment","title":"Deployment","text":"<pre><code># Install\nhelm install my-agents ./chart -f values.yaml\n\n# Upgrade\nhelm upgrade my-agents ./chart -f values.yaml -f values-prod.yaml\n\n# With secrets\nhelm install my-agents ./chart \\\n  -f values.yaml \\\n  --set secrets.geminiApiKey=$GEMINI_API_KEY\n</code></pre>"},{"location":"platforms/kubernetes/#security-configuration","title":"Security Configuration","text":"<pre><code>podSecurityContext:\n  runAsNonRoot: true\n  runAsUser: 1000\n  runAsGroup: 1000\n  fsGroup: 1000\n\nsecurityContext:\n  allowPrivilegeEscalation: false\n  readOnlyRootFilesystem: true\n  capabilities:\n    drop:\n      - ALL\n\nvaultguard:\n  enabled: true\n  minSecurityScore: 50\n  requireEncryption: true\n  requireIam: true\n  deniedNamespaces:\n    - kube-system\n    - default\n</code></pre>"},{"location":"platforms/kubernetes/#resource-management","title":"Resource Management","text":"<pre><code>agents:\n  research:\n    resources:\n      requests:\n        cpu: 100m\n        memory: 128Mi\n      limits:\n        cpu: 1000m\n        memory: 1Gi\n    autoscaling:\n      enabled: true\n      minReplicas: 2\n      maxReplicas: 20\n      targetCPUUtilizationPercentage: 70\n      targetMemoryUtilizationPercentage: 80\n      behavior:\n        scaleDown:\n          stabilizationWindowSeconds: 300\n        scaleUp:\n          stabilizationWindowSeconds: 60\n    pdb:\n      enabled: true\n      minAvailable: \"50%\"\n</code></pre>"},{"location":"platforms/kubernetes/#next-steps","title":"Next Steps","text":"<ul> <li>AWS AgentCore - Alternative serverless deployment</li> <li>Local Development - Test before deploying</li> </ul>"},{"location":"server-factories/","title":"Server Factories","text":"<p>AgentKit provides server factories that eliminate boilerplate code for setting up agent servers.</p>"},{"location":"server-factories/#the-problem","title":"The Problem","text":"<p>Every agent project repeats the same patterns:</p> Pattern Lines Duplicated A2A server setup ~350 lines HTTP server setup ~125 lines HTTP handler setup ~100 lines Total ~575 lines"},{"location":"server-factories/#the-solution","title":"The Solution","text":"<p>Server factories reduce this to ~10 lines:</p> Factory Before After Savings <code>a2a.NewServer()</code> ~70 lines ~5 lines 93% <code>httpserver.New()</code> ~25 lines ~5 lines 80%"},{"location":"server-factories/#available-factories","title":"Available Factories","text":""},{"location":"server-factories/#a2a-server","title":"A2A Server","text":"<p>For agent-to-agent communication using the A2A protocol:</p> <pre><code>server, _ := a2a.NewServer(a2a.Config{\n    Agent:       myAgent,\n    Port:        \"9001\",\n    Description: \"My agent\",\n})\nserver.Start(ctx)\n</code></pre>"},{"location":"server-factories/#http-server","title":"HTTP Server","text":"<p>For REST API endpoints:</p> <pre><code>server, _ := httpserver.NewBuilder(\"my-agent\", 8001).\n    WithHandlerFunc(\"/process\", agent.HandleProcess).\n    Build()\nserver.Start()\n</code></pre>"},{"location":"server-factories/#combining-servers","title":"Combining Servers","text":"<p>Run both HTTP and A2A servers in the same application:</p> <pre><code>func main() {\n    ctx := context.Background()\n\n    // HTTP server for REST API\n    httpServer, _ := httpserver.NewBuilder(\"my-agent\", 8001).\n        WithHandlerFunc(\"/process\", agent.HandleProcess).\n        Build()\n\n    // A2A server for agent communication\n    a2aServer, _ := a2a.NewServer(a2a.Config{\n        Agent: myAgent,\n        Port:  \"9001\",\n    })\n\n    // Start both\n    a2aServer.StartAsync(ctx)  // Non-blocking\n    httpServer.Start()          // Blocking\n}\n</code></pre>"},{"location":"server-factories/#built-in-features","title":"Built-in Features","text":"<p>All server factories include:</p> <ul> <li>Health check endpoints (<code>/health</code> or <code>/ping</code>)</li> <li>Graceful shutdown</li> <li>Configurable timeouts</li> <li>Request logging options</li> <li>Async/sync start modes</li> </ul>"},{"location":"server-factories/#next-steps","title":"Next Steps","text":"<ul> <li>A2A Server Documentation</li> <li>HTTP Server Documentation</li> </ul>"},{"location":"server-factories/a2a/","title":"A2A Server","text":"<p>The A2A (Agent-to-Agent) server factory provides a complete A2A protocol server with minimal configuration.</p>"},{"location":"server-factories/a2a/#basic-usage","title":"Basic Usage","text":"<pre><code>import \"github.com/agentplexus/agentkit/a2a\"\n\nserver, err := a2a.NewServer(a2a.Config{\n    Agent:       myAgent,\n    Port:        \"9001\",\n    Description: \"Research agent for web search\",\n})\nif err != nil {\n    log.Fatal(err)\n}\n\nserver.Start(ctx)  // Blocking\n</code></pre>"},{"location":"server-factories/a2a/#configuration-options","title":"Configuration Options","text":"<pre><code>server, _ := a2a.NewServer(a2a.Config{\n    // Required\n    Agent: myAgent,  // Google ADK agent\n\n    // Optional\n    Port:              \"9001\",            // Empty = random port\n    Description:       \"My agent\",        // Override agent description\n    InvokePath:        \"/invoke\",         // Default: /invoke\n    ReadHeaderTimeout: 10 * time.Second,  // Default: 10s\n    SessionService:    customService,     // Default: in-memory\n})\n</code></pre>"},{"location":"server-factories/a2a/#server-methods","title":"Server Methods","text":"<pre><code>// URLs\nserver.URL()          // \"http://localhost:9001\"\nserver.AgentCardURL() // \"http://localhost:9001/.well-known/agent.json\"\nserver.InvokeURL()    // \"http://localhost:9001/invoke\"\nserver.Addr()         // net.Addr\n\n// Lifecycle\nserver.Start(ctx)      // Blocking start\nserver.StartAsync(ctx) // Non-blocking start\nserver.Stop(ctx)       // Graceful shutdown\n</code></pre>"},{"location":"server-factories/a2a/#endpoints","title":"Endpoints","text":"<p>The server provides these endpoints:</p> Endpoint Description <code>/.well-known/agent.json</code> Agent card (capabilities, skills) <code>/invoke</code> JSON-RPC invocation endpoint <code>/health</code> Health check"},{"location":"server-factories/a2a/#before-manual-setup-70-lines","title":"Before: Manual Setup (~70 lines)","text":"<pre><code>func startA2AServer(agent agent.Agent, port string) error {\n    listener, err := net.Listen(\"tcp\", \"0.0.0.0:\"+port)\n    if err != nil {\n        return fmt.Errorf(\"failed to create listener: %w\", err)\n    }\n\n    baseURL, _ := url.Parse(fmt.Sprintf(\"http://localhost:%s\", port))\n    agentPath := \"/invoke\"\n\n    agentCard := &amp;a2a.AgentCard{\n        Name:               agent.Name(),\n        Description:        \"Agent description here\",\n        Skills:             adka2a.BuildAgentSkills(agent),\n        PreferredTransport: a2a.TransportProtocolJSONRPC,\n        URL:                baseURL.JoinPath(agentPath).String(),\n        Capabilities:       a2a.AgentCapabilities{Streaming: true},\n    }\n\n    mux := http.NewServeMux()\n    mux.Handle(a2asrv.WellKnownAgentCardPath,\n        a2asrv.NewStaticAgentCardHandler(agentCard))\n\n    executor := adka2a.NewExecutor(adka2a.ExecutorConfig{\n        RunnerConfig: runner.Config{\n            AppName:        agent.Name(),\n            Agent:          agent,\n            SessionService: session.InMemoryService(),\n        },\n    })\n\n    requestHandler := a2asrv.NewHandler(executor)\n    mux.Handle(agentPath, a2asrv.NewJSONRPCHandler(requestHandler))\n\n    mux.HandleFunc(\"/health\", func(w http.ResponseWriter, r *http.Request) {\n        w.WriteHeader(http.StatusOK)\n        w.Write([]byte(\"OK\"))\n    })\n\n    server := &amp;http.Server{\n        Handler:           mux,\n        ReadHeaderTimeout: 10 * time.Second,\n    }\n\n    log.Printf(\"A2A server starting on port %s\", port)\n    return server.Serve(listener)\n}\n</code></pre>"},{"location":"server-factories/a2a/#after-with-agentkit-5-lines","title":"After: With AgentKit (~5 lines)","text":"<pre><code>server, _ := a2a.NewServer(a2a.Config{\n    Agent:       myAgent,\n    Port:        \"9001\",\n    Description: \"Research agent for web search\",\n})\nserver.Start(ctx)\n</code></pre>"},{"location":"server-factories/a2a/#testing","title":"Testing","text":"<p>Use a random port for tests:</p> <pre><code>func TestA2AServer(t *testing.T) {\n    server, _ := a2a.NewServer(a2a.Config{\n        Agent: myAgent,\n        Port:  \"\", // Random port\n    })\n\n    server.StartAsync(context.Background())\n    defer server.Stop(context.Background())\n\n    // Fetch agent card\n    resp, err := http.Get(server.AgentCardURL())\n    assert.NoError(t, err)\n    assert.Equal(t, 200, resp.StatusCode)\n\n    var card map[string]interface{}\n    json.NewDecoder(resp.Body).Decode(&amp;card)\n    assert.Equal(t, \"my-agent\", card[\"name\"])\n}\n</code></pre>"},{"location":"server-factories/a2a/#custom-session-service","title":"Custom Session Service","text":"<p>For production, you may want persistent sessions:</p> <pre><code>// Custom session service\nsessionService := myCustomSessionService()\n\nserver, _ := a2a.NewServer(a2a.Config{\n    Agent:          myAgent,\n    Port:           \"9001\",\n    SessionService: sessionService,\n})\n</code></pre>"},{"location":"server-factories/httpserver/","title":"HTTP Server","text":"<p>The HTTP server factory provides a production-ready HTTP server with minimal configuration.</p>"},{"location":"server-factories/httpserver/#builder-pattern-recommended","title":"Builder Pattern (Recommended)","text":"<pre><code>import \"github.com/agentplexus/agentkit/httpserver\"\n\nserver, err := httpserver.NewBuilder(\"my-agent\", 8001).\n    WithHandlerFunc(\"/process\", agent.HandleProcess).\n    WithHandlerFunc(\"/analyze\", agent.HandleAnalyze).\n    WithDualModeLog().\n    Build()\n\nif err != nil {\n    log.Fatal(err)\n}\n\nserver.Start()\n</code></pre>"},{"location":"server-factories/httpserver/#config-based","title":"Config-Based","text":"<pre><code>server, err := httpserver.New(httpserver.Config{\n    Name: \"my-agent\",\n    Port: 8001,\n    HandlerFuncs: map[string]http.HandlerFunc{\n        \"/process\": agent.HandleProcess,\n        \"/analyze\": agent.HandleAnalyze,\n    },\n    EnableDualModeLog: true,\n})\n</code></pre>"},{"location":"server-factories/httpserver/#builder-methods","title":"Builder Methods","text":"<pre><code>httpserver.NewBuilder(\"name\", port).\n    // Handlers\n    WithHandlerFunc(\"/path\", handlerFunc).  // http.HandlerFunc\n    WithHandler(\"/path\", handler).           // http.Handler\n\n    // Timeouts\n    WithTimeouts(read, write, idle).\n\n    // Health check\n    WithHealthPath(\"/health\").              // Default: /health\n    WithHealthHandler(customHealthFunc).\n\n    // Logging\n    WithDualModeLog().                      // Log startup info\n\n    Build()\n</code></pre>"},{"location":"server-factories/httpserver/#configuration-options","title":"Configuration Options","text":"<pre><code>httpserver.Config{\n    Name:              \"my-agent\",\n    Port:              8001,\n\n    // Handlers\n    Handlers:          map[string]http.Handler{...},\n    HandlerFuncs:      map[string]http.HandlerFunc{...},\n\n    // Timeouts\n    ReadTimeout:       30 * time.Second,   // Default: 30s\n    WriteTimeout:      120 * time.Second,  // Default: 120s\n    IdleTimeout:       60 * time.Second,   // Default: 60s\n\n    // Health\n    HealthPath:        \"/health\",          // Default: /health\n    HealthHandler:     customHealthFunc,   // Default: returns \"OK\"\n\n    // Logging\n    EnableDualModeLog: true,\n}\n</code></pre>"},{"location":"server-factories/httpserver/#server-methods","title":"Server Methods","text":"<pre><code>// Lifecycle\nserver.Start()              // Blocking start\nserver.StartAsync()         // Non-blocking start\nserver.Stop(ctx)            // Graceful shutdown\n\n// Info\nserver.URL()                // \"http://localhost:8001\"\nserver.Addr()               // \":8001\"\n</code></pre>"},{"location":"server-factories/httpserver/#with-orchestration","title":"With Orchestration","text":"<p>Use with the orchestration package for workflow-based handlers:</p> <pre><code>import (\n    \"github.com/agentplexus/agentkit/httpserver\"\n    \"github.com/agentplexus/agentkit/orchestration\"\n)\n\n// Create executor from workflow\nexecutor := orchestration.NewExecutor(graph, \"my-workflow\")\n\n// Wrap as HTTP handler\nhandler := orchestration.NewHTTPHandler(executor)\n\n// Add to server\nserver, _ := httpserver.NewBuilder(\"my-agent\", 8001).\n    WithHandler(\"/workflow\", handler).\n    Build()\n</code></pre>"},{"location":"server-factories/httpserver/#before-manual-setup-25-lines","title":"Before: Manual Setup (~25 lines)","text":"<pre><code>func startHTTPServer(agent *ResearchAgent) error {\n    server := &amp;http.Server{\n        Addr:         \":8001\",\n        ReadTimeout:  30 * time.Second,\n        WriteTimeout: 120 * time.Second,\n        IdleTimeout:  60 * time.Second,\n    }\n\n    http.HandleFunc(\"/research\", agent.HandleResearchRequest)\n    http.HandleFunc(\"/health\", func(w http.ResponseWriter, r *http.Request) {\n        w.WriteHeader(http.StatusOK)\n        if _, err := w.Write([]byte(\"OK\")); err != nil {\n            log.Printf(\"Failed to write health response: %v\", err)\n        }\n    })\n\n    log.Println(\"Research Agent HTTP server starting on :8001\")\n    log.Println(\"(Dual mode: HTTP for security/observability, A2A for interoperability)\")\n\n    if err := server.ListenAndServe(); err != nil {\n        log.Fatalf(\"HTTP server failed: %v\", err)\n    }\n    return nil\n}\n</code></pre>"},{"location":"server-factories/httpserver/#after-with-agentkit-5-lines","title":"After: With AgentKit (~5 lines)","text":"<pre><code>server, _ := httpserver.NewBuilder(\"research-agent\", 8001).\n    WithHandlerFunc(\"/research\", agent.HandleResearchRequest).\n    WithDualModeLog().\n    Build()\n\nserver.Start()\n</code></pre>"},{"location":"server-factories/httpserver/#testing","title":"Testing","text":"<p>Use port 0 for random port assignment in tests:</p> <pre><code>func TestHTTPServer(t *testing.T) {\n    server, _ := httpserver.NewBuilder(\"test-agent\", 0).\n        WithHandlerFunc(\"/test\", testHandler).\n        Build()\n\n    server.StartAsync()\n    defer server.Stop(context.Background())\n\n    resp, err := http.Get(server.URL() + \"/test\")\n    assert.NoError(t, err)\n    assert.Equal(t, 200, resp.StatusCode)\n}\n</code></pre>"},{"location":"server-factories/httpserver/#multiple-handlers","title":"Multiple Handlers","text":"<pre><code>server, _ := httpserver.NewBuilder(\"multi-agent\", 8001).\n    WithHandlerFunc(\"/research\", agent.HandleResearch).\n    WithHandlerFunc(\"/synthesize\", agent.HandleSynthesize).\n    WithHandlerFunc(\"/verify\", agent.HandleVerify).\n    WithHandler(\"/workflow\", orchestration.NewHTTPHandler(executor)).\n    Build()\n</code></pre>"}]}